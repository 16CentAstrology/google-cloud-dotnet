Contributing
============

1. **Please sign one of the contributor license agreements below.**
1. Fork the repo, develop and test your code changes, add docs.
1. Make sure that your commit messages clearly describe the changes.
1. Send a pull request.

Contributor License Agreements
------------------------------

Before we can accept your pull requests you'll need to sign a Contributor
License Agreement (CLA):

- **If you are an individual writing original source code** and **you own the intellectual property**,
then you'll need to sign an [individual CLA][individual-cla].
- **If you work for a company that wants to allow you to contribute your work**,
then you'll need to sign a [corporate CLA][corporate-cla].

You can sign these electronically (just scroll to the bottom). After that,
we'll be able to accept your pull requests.

[individual-cla]: https://developers.google.com/open-source/cla/individual
[corporate-cla]: https://developers.google.com/open-source/cla/corporate

Code Style
==========

Goals
-----

**Provide idiomatic .NET support for a subset of Google Cloud Platform Services**

The approach taken is client-code-first: "if I wanted to perform a particular
task in C# using Google Cloud Services and I could make the implementation do
whatever I want, what would the API look like?"

This extends to making it as simple as humanly possible to accomplish simple
tasks. More complex or unusual tasks may be harder or even impossible, but we're
heavily biased towards common use cases.

The Google Cloud Services are designed around REST and RPC principles which
allow a lot of flexibility for all scenarios, but aren't necessarily the simplest
way of expressing common goals. The `Google.GCloud` library is designed to hide
this from callers, sometimes aggregating multiple requests behind a single
method call.

**Let you test your code**

We hate code that can't be tested. Clearly you can run regression tests against
test instances of *actual* Google Cloud Platform services, but you probably want
to be able to run unit tests locally, too. Each service has a *limited*
[test double](http://en.wikipedia.org/wiki/Test_double) of some kind - where
the implementation faithfulness to the real service may vary significantly.

**Avoid global state**

This goes alongside letting your test your code, really: while some explicit
calls around authentication use environmental state to "do the right thing"
automatically, this is easily extracted from the rest of your code, and no global
state is mutated.

Non-goals
---------

**Provide access to every operation in every service**

`Google.GCloud` is a complementary project to the autogenerated client libraries
and [GRPC](http://grpc.io/) code generation. They can be used together in order
to support common tasks on a simple basis, dropping down to lower-level APIs
for anything else. However, this is a binary choice for any given operation: the
underlying calls are not exposed via `Google.GCloud`, so if the API surface does
not allow you to configure a particular option, it can't be added by providing
(for example) a custom RPC request.

**Provide a fully-compatible local stack for every service**

The aim of the test doubles is purely to allow testing of code using this library.
They do not generally provide the same underlying RPC API, and avoid persisting
any data. They're fine for unit tests, but full system tests should be performed
against real servers.
